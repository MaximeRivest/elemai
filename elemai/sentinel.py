"""_ai sentinel for marking LLM-generated outputs."""

import inspect
from typing import Any, Optional


class AISentinel:
    """
    Sentinel value representing an LLM-generated output.

    When used in a function body, indicates that this value should be
    generated by the LLM. Supports subscript notation for descriptions.

    Examples:
        thinking: str = _ai["Think step by step"]
        result = _ai
    """

    def __init__(self, description: Optional[str] = None):
        self.description = description

    def __getitem__(self, description: str) -> 'AISentinel':
        """Support _ai["description"] syntax."""
        return AISentinel(description=description)

    def __repr__(self) -> str:
        if self.description:
            return f"_ai[{self.description!r}]"
        return "_ai"


# The global _ai sentinel
_ai = AISentinel()


class FunctionIntrospector:
    """Introspects a function to extract AI task metadata."""

    def __init__(self, func):
        self.func = func
        self.signature = inspect.signature(func)
        self.source = None
        try:
            self.source = inspect.getsource(func)
        except (OSError, TypeError):
            pass

    def get_input_fields(self):
        """Extract input fields from function signature."""
        fields = []
        for name, param in self.signature.parameters.items():
            if name == 'self':
                continue

            field_type = param.annotation if param.annotation != inspect.Parameter.empty else Any
            fields.append({
                'name': name,
                'type': field_type,
                'default': param.default if param.default != inspect.Parameter.empty else None
            })
        return fields

    def get_output_fields(self):
        """
        Extract output fields by analyzing function body for _ai assignments.

        Returns:
            List of dicts with 'name', 'type', 'description'
        """
        fields = []

        if not self.source:
            # If we can't get source, infer from return annotation
            return_type = self.signature.return_annotation
            if return_type != inspect.Signature.empty:
                fields.append({
                    'name': 'result',
                    'type': return_type,
                    'description': None
                })
            return fields

        # Parse the source to find _ai assignments
        lines = self.source.split('\n')

        for line in lines:
            line = line.strip()

            # Match patterns like: thinking: str = _ai["description"]
            # or: thinking: str = _ai
            if '= _ai' in line and not line.startswith('#'):
                # Extract variable name and type
                parts = line.split('=')[0].strip()

                if ':' in parts:
                    var_name = parts.split(':')[0].strip()
                    type_hint = parts.split(':')[1].strip()

                    # Try to resolve type hint
                    var_type = self._resolve_type(type_hint)
                else:
                    var_name = parts.strip()
                    var_type = Any

                # Extract description if present
                description = None
                if '[' in line and ']' in line:
                    # Extract description from _ai["description"]
                    desc_match = line.split('[')[1].split(']')[0]
                    description = desc_match.strip('"\'')

                fields.append({
                    'name': var_name,
                    'type': var_type,
                    'description': description
                })

        # Also check return statement
        if 'return _ai' in self.source:
            return_type = self.signature.return_annotation
            if return_type != inspect.Signature.empty:
                # Check if we already have a 'result' field
                if not any(f['name'] == 'result' for f in fields):
                    fields.append({
                        'name': 'result',
                        'type': return_type,
                        'description': None
                    })

        return fields

    def _resolve_type(self, type_str: str):
        """Attempt to resolve a type string to an actual type."""
        # Get the function's globals for type resolution
        func_globals = self.func.__globals__

        # Common built-in types
        builtin_types = {
            'str': str,
            'int': int,
            'float': float,
            'bool': bool,
            'list': list,
            'dict': dict,
            'Any': Any,
        }

        # Try built-ins first
        if type_str in builtin_types:
            return builtin_types[type_str]

        # Try to evaluate in function's namespace
        try:
            return eval(type_str, func_globals)
        except:
            return Any

    def get_instruction(self):
        """Extract instruction from docstring."""
        doc = inspect.getdoc(self.func)
        if doc:
            # Use first line as instruction
            return doc.split('\n')[0].strip()
        return f"Perform {self.func.__name__}"

    def get_full_docstring(self):
        """Get the complete docstring."""
        return inspect.getdoc(self.func) or ""

    def introspect(self):
        """
        Perform full introspection of the function.

        Returns:
            Dict with all metadata
        """
        return {
            'fn_name': self.func.__name__,
            'instruction': self.get_instruction(),
            'doc': self.get_full_docstring(),
            'input_fields': self.get_input_fields(),
            'output_fields': self.get_output_fields(),
            'return_type': self.signature.return_annotation,
        }
